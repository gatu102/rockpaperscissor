import tkinter as tk
from tkinter import simpledialog, messagebox
import random
import os
from collections import Counter

# ---------------- Config ----------------
LEADERBOARD_FILE = "rps_leaderboard.txt"
MAX_LEADERBOARD_ENTRIES = 5
FONT_MAIN = ("Arial", 12)
FONT_TITLE = ("Arial", 14, "bold")
# ----------------------------------------

# Leaderboard handling
def load_leaderboard():
    leaderboard = []
    if os.path.exists(LEADERBOARD_FILE):
        with open(LEADERBOARD_FILE, "r") as f:
            for line in f:
                try:
                    name, score = line.strip().split(",")
                    leaderboard.append((name, int(score)))
                except ValueError:
                    continue
    return sorted(leaderboard, key=lambda x: x[1], reverse=True)

def save_leaderboard(name, score):
    leaderboard = load_leaderboard()
    leaderboard.append((name, score))
    leaderboard.sort(key=lambda x: x[1], reverse=True)
    with open(LEADERBOARD_FILE, "w") as f:
        for entry in leaderboard[:MAX_LEADERBOARD_ENTRIES]:
            f.write(f"{entry[0]},{entry[1]}\n")

# ---------------- RPS Game ----------------
class RPSGame:
    def __init__(self, root):
        self.root = root
        self.root.title("üéÆ Rock Paper Scissors Showdown")
        self.choices = ["Rock", "Paper", "Scissors"]
        self.emojis = {"Rock": "ü™®", "Paper": "üìÑ", "Scissors": "‚úÇÔ∏è"}

        # Game state
        self.wins = 0
        self.losses = 0
        self.ties = 0
        self.rounds = 0
        self.current_round = 0
        self.player_history = []
        self.player_name = "Player"
        self.tournament_mode = False

        # AI difficulty
        self.ai_level = tk.StringVar(value="Easy")

        self.create_widgets()
        self.show_leaderboard()

    # ---------------- UI ----------------
    def create_widgets(self):
        # Tournament button
        tk.Button(self.root, text="Start Tournament", font=FONT_MAIN,
                  command=self.start_tournament).pack(pady=5)

        # AI Difficulty selection
        tk.Label(self.root, text="Select AI Difficulty:", font=FONT_MAIN).pack(pady=5)
        tk.OptionMenu(self.root, self.ai_level, "Easy", "Medium", "Hard").pack(pady=5)

        # Info label
        self.label_info = tk.Label(self.root, text="Choose your move!", font=FONT_TITLE)
        self.label_info.pack(pady=10)

        # Buttons for choices
        self.frame_buttons = tk.Frame(self.root)
        self.frame_buttons.pack(pady=5)
        for choice in self.choices:
            tk.Button(
                self.frame_buttons,
                text=f"{self.emojis[choice]} {choice}",
                width=10, height=2, font=FONT_MAIN,
                command=lambda c=choice: self.play(c)
            ).pack(side="left", padx=5)

        # Result display
        self.label_result = tk.Label(self.root, text="", font=FONT_MAIN, fg="blue")
        self.label_result.pack(pady=10)

        # Scoreboard
        self.label_score = tk.Label(self.root, text=self.get_score_text(), font=FONT_MAIN)
        self.label_score.pack(pady=10)

        # Leaderboard
        self.label_leaderboard = tk.Label(self.root, text="", font=FONT_MAIN, justify="left")
        self.label_leaderboard.pack(pady=10)

        # Reset button
        tk.Button(self.root, text="Reset Game", font=FONT_MAIN,
                  command=self.reset_game).pack(pady=10)

    # ---------------- Game Logic ----------------
    def get_score_text(self):
        rounds_info = f"{self.current_round}/{self.rounds}" if self.tournament_mode else "-"
        return f"Wins: {self.wins} | Losses: {self.losses} | Ties: {self.ties} | Round: {rounds_info}"

    def computer_choice(self):
        level = self.ai_level.get()
        if level == "Easy":
            return random.choice(self.choices)
        elif level == "Medium":
            if not self.player_history or random.random() < 0.5:
                return random.choice(self.choices)
            return self.counter_move(self.player_history[-1])
        elif level == "Hard":
            if not self.player_history:
                return random.choice(self.choices)
            most_common = Counter(self.player_history).most_common(1)[0][0]
            return self.counter_move(most_common)

    @staticmethod
    def counter_move(move):
        return {"Rock": "Paper", "Paper": "Scissors", "Scissors": "Rock"}[move]

    def play(self, player_choice):
        if self.tournament_mode and self.current_round >= self.rounds:
            messagebox.showinfo("Tournament Over", "Tournament is finished. Start a new tournament.")
            return

        self.player_history.append(player_choice)
        computer_choice = self.computer_choice()

        result_text = (
            f"You chose {self.emojis[player_choice]} {player_choice}.\n"
            f"Computer chose {self.emojis[computer_choice]} {computer_choice}.\n"
        )

        if player_choice == computer_choice:
            result_text += "üòê It's a tie!"
            self.ties += 1
        elif (player_choice == "Rock" and computer_choice == "Scissors") or \
             (player_choice == "Paper" and computer_choice == "Rock") or \
             (player_choice == "Scissors" and computer_choice == "Paper"):
            result_text += "üéâ You win!"
            self.wins += 1
        else:
            result_text += "üíª Computer wins!"
            self.losses += 1

        self.current_round += 1
        self.label_result.config(text=result_text)
        self.label_score.config(text=self.get_score_text())

        if self.tournament_mode and self.current_round == self.rounds:
            self.end_tournament()

    def start_tournament(self):
        name = simpledialog.askstring("Name", "Enter your name for the tournament:")
        self.player_name = name if name else "Player"
        try:
            self.rounds = int(simpledialog.askstring("Rounds", "Enter number of rounds:") or 5)
        except ValueError:
            self.rounds = 5

        self.tournament_mode = True
        self.current_round = 0
        self.reset_scores()

        self.label_result.config(
            text=f"Tournament started for {self.player_name} - {self.rounds} rounds!"
        )
        self.label_score.config(text=self.get_score_text())

    def end_tournament(self):
        result = f"Tournament Over! Final Score:\nWins: {self.wins} | Losses: {self.losses} | Ties: {self.ties}"
        messagebox.showinfo("Tournament Finished", result)
        save_leaderboard(self.player_name, self.wins)
        self.show_leaderboard()

    def show_leaderboard(self):
        leaderboard = load_leaderboard()
        text = "üèÜ Leaderboard (Top 5 Wins)\n"
        text += "\n".join(f"{i}. {name} - {score}" for i, (name, score) in enumerate(leaderboard[:5], 1))
        self.label_leaderboard.config(text=text)

    # ---------------- Reset ----------------
    def reset_scores(self):
        self.wins = self.losses = self.ties = 0
        self.player_history = []

    def reset_game(self):
        self.reset_scores()
        self.current_round = 0
        self.tournament_mode = False
        self.label_result.config(text="")
        self.label_score.config(text=self.get_score_text())
        self.show_leaderboard()

# ---------------- Run Game ----------------
if __name__ == "__main__":
    root = tk.Tk()
    RPSGame(root)
    root.mainloop()
