import tkinter as tk
from tkinter import messagebox
import random
import os


HIGH_SCORE_FILE = "rps_highscore.txt"

def load_high_score():
    if os.path.exists(HIGH_SCORE_FILE):
        with open(HIGH_SCORE_FILE, "r") as f:
            try:
                return int(f.read())
            except:
                return 0
    return 0

def save_high_score(score):
    with open(HIGH_SCORE_FILE, "w") as f:
        f.write(str(score))

def rock_paper_scissors():
    print("🎮 Welcome to Rock Paper Scissors Showdown!")
    print("Choices: rock (r), paper (p), scissors (s)")

    choices = ["rock", "paper", "scissors"]
    choice_shortcuts = {"r": "rock", "p": "paper", "s": "scissors"}

    wins = 0
    losses = 0
    ties = 0
    high_score = load_high_score()

    # Ask for number of rounds
    try:
        rounds = int(input("Enter number of rounds (or 0 for infinite): "))
    except ValueError:
        rounds = 0

    round_count = 0
    while rounds == 0 or round_count < rounds:
        round_count += 1
        player_input = input(f"\nRound {round_count} - Enter your choice: ").lower()
        player = choice_shortcuts.get(player_input, player_input)
        if player not in choices:
            print("Invalid choice. Choose rock, paper, or scissors (or r/p/s).")
            round_count -= 1
            continue

        # Weighted computer choice (optional: smarter AI)
        computer = random.choice(choices)
        print(f"Computer chose: {computer}")

        # Determine winner
        if player == computer:
            print("It's a tie!")
            ties += 1
        elif (player == "rock" and computer == "scissors") or \
             (player == "paper" and computer == "rock") or \
             (player == "scissors" and computer == "paper"):
            print("🎉 You win!")
            wins += 1
        else:
            print("💀 You lose!")
            losses += 1

        print(f"Score → Wins: {wins} | Losses: {losses} | Ties: {ties}")
        # Update high score
        if wins > high_score:
            high_score = wins
            save_high_score(high_score)

        # Continue or exit
        if rounds == 0:
            again = input("Play another round? (y/n): ").lower()
            if again != "y":
                break

    print("\nThanks for playing Rock Paper Scissors Showdown!")
    print(f"Final Score → Wins: {wins} | Losses: {losses} | Ties: {ties}")
    print(f"High Score: {high_score}")
=======

HIGH_SCORE_FILE = "rps_gui_highscore.txt"

def load_high_score():
    if os.path.exists(HIGH_SCORE_FILE):
        with open(HIGH_SCORE_FILE, "r") as f:
            try:
                return int(f.read())
            except:
                return 0
    return 0

def save_high_score(score):
    with open(HIGH_SCORE_FILE, "w") as f:
        f.write(str(score))

class RPSGame:
    def __init__(self, root):
        self.root = root
        self.root.title("🎮 Rock Paper Scissors Showdown")
        self.choices = ["Rock", "Paper", "Scissors"]
        self.emojis = {"Rock":"🪨","Paper":"📄","Scissors":"✂️"}
        self.wins = 0
        self.losses = 0
        self.ties = 0
        self.high_score = load_high_score()

        self.create_widgets()

    def create_widgets(self):
        # Display Labels
        self.label_info = tk.Label(self.root, text="Choose your move!", font=("Arial", 14))
        self.label_info.pack(pady=10)

        self.frame_buttons = tk.Frame(self.root)
        self.frame_buttons.pack(pady=5)

        # Rock, Paper, Scissors Buttons
        for choice in self.choices:
            btn = tk.Button(self.frame_buttons, text=f"{self.emojis[choice]} {choice}", width=10, height=2, font=("Arial",12),
                            command=lambda c=choice: self.play(c))
            btn.pack(side="left", padx=5)

        # Result display
        self.label_result = tk.Label(self.root, text="", font=("Arial", 12))
        self.label_result.pack(pady=10)

        # Scoreboard
        self.label_score = tk.Label(self.root, text=self.get_score_text(), font=("Arial", 12))
        self.label_score.pack(pady=10)

        # Reset Button
        self.btn_reset = tk.Button(self.root, text="Reset Game", command=self.reset_game)
        self.btn_reset.pack(pady=10)

    def get_score_text(self):
        return f"Wins: {self.wins} | Losses: {self.losses} | Ties: {self.ties} | High Score: {self.high_score}"

    def play(self, player_choice):
        computer_choice = random.choice(self.choices)
        result_text = f"You chose {self.emojis[player_choice]} {player_choice}.\nComputer chose {self.emojis[computer_choice]} {computer_choice}.\n"

        # Determine winner
        if player_choice == computer_choice:
            result_text += "It's a tie!"
            self.ties += 1
        elif (player_choice=="Rock" and computer_choice=="Scissors") or \
             (player_choice=="Paper" and computer_choice=="Rock") or \
             (player_choice=="Scissors" and computer_choice=="Paper"):
            result_text += "🎉 You win!"
            self.wins += 1
        else:
            result_text += "💀 You lose!"
            self.losses += 1

        # Update high score
        if self.wins > self.high_score:
            self.high_score = self.wins
            save_high_score(self.high_score)

        self.label_result.config(text=result_text)
        self.label_score.config(text=self.get_score_text())

    def reset_game(self):
        self.wins = 0
        self.losses = 0
        self.ties = 0
        self.label_result.config(text="")
        self.label_score.config(text=self.get_score_text())


if __name__ == "__main__":
    root = tk.Tk()
    game = RPSGame(root)
    root.mainloop()
